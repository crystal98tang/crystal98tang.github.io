{"compress":true,"commitItems":[["3adfc674-6c68-46aa-aa1e-3156da4b28a2",1561022289014,"",[[1561022237229,["tyk50@tangyukun",[[1,0,"# 2019-04-10-\n\n\n\n"]],[0,0],[16,16]]],[1561022270530,["tyk50@tangyukun",[[-1,0,"#"],[1,1,"---\nlayout: post\ntitle: Design Patterns\ndate:"],[-1,10,"1"],[1,12,"9\ntags:\n  "],[1,13," JAVA "],[1,14,"categories: "],[1,15,"  - JAVA\n---\n==第七周WEB JAVA作业（1）==\n<!-- more -->"]],[0,16],[134,134]]],[1561022273886,["tyk50@tangyukun",[[-1,115,"1"]],[116,116],[115,115]]],[1561022273941,["tyk50@tangyukun",[[1,115,"2"]],[115,115],[116,116]]],[1561022276990,["tyk50@tangyukun",[[-1,54,"09"]],[56,56],[54,54]]],[1561022277838,["tyk50@tangyukun",[[1,54,"10"]],[54,54],[56,56]]],[1561022283571,["tyk50@tangyukun",[[-1,23," Design Pattern"],[1,38,"# CDI Feature"]],[23,39],[37,37]]],[1561022285362,["tyk50@tangyukun",[[-1,23,"# "]],[24,24],[23,23]]],[1561022286028,["tyk50@tangyukun",[[1,23," "]],[23,23],[24,24]]],[1561022297469,["tyk50@tangyukun",[[1,131,"一、EL/SpEL\n\n1、EL语言(CDI与表达式语言（EL）集成，允许在JavaServer Faces页面或JavaServer Pages页面中直接使用任何组件)\n\n1）概述；\nEL是JSP内置的表达式语言，用以访问页面的上下文以及不同作用域中的对象 ，\n取得对象属性的值，或执行简单的运算或判断操作。EL在得到某个数据时，会自动进行数据类型的转换。\n使用EL表达式输出数据时，如果有则输出数据，如果为null则什么也不输出。\n\n2）语法：\na.EL表达式总是放在{}中，而且前边有一个作为前缀:作为前缀:作为前缀:{}\nb.获取对象的属性值可以直接通过“对象.属性名”:user.name;注意：这里的属性名是get和set方法对应的属性值，并不是对象中的变量名。c.获取对象的属性也可以通过“对象[“属性名”]”:{user.name};注意：这里的属性名是get和set方法对应的属性值，并不是对象中的变量名。c.获取对象的属性也可以通过“对象[“属性名”]”:user.name;注意：这里的属性名是get和set方法对应的属性值，并不是对象中的变量名。c.获取对象的属性也可以通过“对象[“属性名”]”:{user[“name”]}\nd.获取Map中属性时可以以直接通过属性的key:map.key,{map.key},map.key,{map[key]}\ne.在指定域中获取属性:\n在EL表达式中如果我们直接使用属性名如：${user}，它将会在四个域中由小到大依次查找。\n顺序：pageScope、requestScope、sessionScope、applicationScope。\n也可以指定从哪个域中获取：\n${ pageScope .user }：当前页面\n${requestScope.user}：当前请求\n${sessionScope.user}：当前会话\n${sessionScope.user}：当前应用\n\n3）EL中包含11个隐含对象，这些对象可以在EL表达式中直接使用：\na.pageContext,和JSP中的pageContext功能一样\nb.请求域:pageScope/requestScope/sessionScope/applicationScope\nc.请求参数,参数对象主要用于获取get或post请求中的参数:\nparam:获取指定的请求参数,param.usernameparamValues:获取请求参数数组，如：{param.username}paramValues:获取请求参数数组，如：param.usernameparamValues:获取请求参数数组，如：{paramValues.sport[1]}\nd.其他:header/headerValues/initParam/cookie\n\n4)EL支持数学运算和逻辑运算：\na.加减乘除:17+5=>22b.取余{17+5} =&gt; 22b.取余%或mod：17+5=>22b.取余{17%5} => 2\nc.比较运算符>,<,==,!=,<=,>=,eq,ne,lt,gt,le,ge：3>5或{3&gt;5}或3>5或{3 gt 5} =>false\nd.逻辑比较 &&或and，!或not，||或or，empty：${!true} => false\n\n2.SpEL\n\n1）Spring框架的表达式语言（简称SpEL）：是一个支持运行时查询和操作对象图的强大的表达式语言。\nSpEL 为 bean 的属性进行动态赋值提供了便利.\n\n2）语法：SpEL 使用 #{…} 作为定界符，所有在大框号中的字符都将被认为是 SpEL。\n\n3）运用范围：\na. 对 bean 进行引用，调用属性值：#{[book.name](http://book.name/)}\nb.调用方法以及引用对象中的属性\n引用方法：#{dog.run()},引用静态方法：#{T(java.lang.Math).PI}\n引用对象的属性：#{[user.name](http://user.name/)}\nc.计算表达式的值\n加减乘除：#{counter.total + 40},#{T(java.lang.Math).PI * 2}\n加号作为字符串连接符：#{[user.name](http://user.name/) + ’ ’ + user.address}\n比较运算符(>,<,=,>=,<=,,lt,gt,eq,le,ge)：\n#{counter.total == 100},#{counter.total le 1000}\nif-else条件判断，三元运算符：\n#{[user.name](http://user.name/)’Tom’ ? ‘Jess’}\n\nd.正则表达式的匹配(matches)\n#{[user.name](http://user.name/) matches ‘[1](https://blog.csdn.net/weixin_38182535/article/details/89165171#fn1){4,16}$’}\ne.字面量的表示：\n#{5},#{89.7},#{1e4},#{false}\n可使用单/双引号作为字符串表达符号:#{‘Chuck’},#{“Chuck”}\n\n二、Decorator(装饰注入组件的能力)\n\n@Decorator\n\n功能：修饰器，横向\n注册一个修饰器类PaintedDecorator.java\n\n@Decorator\npublic class PaintedDecorator implements Room {\n\n@Inject\n@Delegate\nRoom roomToBeDecorated; //注册被修饰的房子，这里是BlankRoom\n\npublic String showRoom() {\ndoPainting();\nreturn roomToBeDecorated.showRoom() + “刷墙漆”;\n}\n\n## // 刷墙漆\nprivate void doPainting() {\nSystem.out.print(“刷墙漆”);\n}\n}\n\n@Decorator\npublic class FlooredDecorator implements Room {\n\n@Inject\n@Delegate\nRoom roomToBeDecorated; //注册被修饰的房子，这里是BlankRoom\n\npublic String showRoom() {\ndoFlooring();\nreturn roomToBeDecorated.showRoom() + “铺地板”;\n}\n// 铺地板\nprivate void doFlooring() {\nSystem.out.print(“装饰地板”);\n}\n}\n注册两个被修饰类BlankRoom.java,修饰的基础\n\npublic class BlankRoom implements Room {\n\npublic String showRoom() {\nreturn “毛胚房”;\n}\n}\n\n激活修饰器，执行顺序由下至上\n\ncn.edu.sdut.softlab.FlooredDecorator cn.edu.sdut.softlab.PaintedDecorator 具体实现\n\n@Named(“room”)\npublic class RoomController {\n\n@Inject\nRoom room;\n\npublic String showRoom() {\nreturn room.showRoom();\n}\n}\n输出\n\n毛胚房刷墙漆铺地板\n\n三、Interceptor(使用类型安全拦截器绑定将拦截器与组件相关联的能力)\n\n@Interceptor\n\n拦截器\n\n功能：断开逻辑插入功能，比如Logger\n定义一个拦截器LoggedInterceptor.java\n@Logged\n@Interceptor\npublic class LoggedInterceptor implements Serializable {\n\npublic LoggedInterceptor(){}\n\n// 拦截之后具体实现\n@AroundInvoke\npublic Object logMethod(InvocationContext ctx) throws Exception {\nSystem.out.println(“Entering method:” + ctx.getMethod().getName()\n\n*   \" in class: \" + ctx.getMethod().getDeclaringClass().getName());\n    return ctx.proceed();\n    }\n    }\n    调用拦截器\n\n@Logged\npublic void checkin(){\nSystem.out.println(“checkin room…”);\n}\n当然拦截器需要在beans.xml上激活\n\ncn.edu.sdut.r314.AuditInterceptor\ncn.edu.sdut.r314.LoggedInterceptor\n\n当然拦截器也可以修饰一整个组件，这样只要调用这个组件的时候就会执行拦截器的内容\n\n@Named\n@Audit\npublic class RoomController {\n\n/**\n\n*   订房\n*   @return\n    */\n    public void checkin(){\n    System.out.println(“checkin room…”);\n    }\n\n/**\n\n*   退房\n*   @return\n    */\n    public void checkout(){\n    System.out.println(“checkout room…”);\n    }\n\n四、Producer(动态注入)\n\n@Produces\n\n功能: 制造组件,自定义组件分配\n\n我们先定义好一个接口Tasks.java以及他的实现类AsyncTask.java , SyncTask.java。以及一个枚举类TaskType.java\n\npublic enum TaskType {\nASYNC,SYNC;\n}\n然后看一下@Produces是怎么调用的\n\n@RequestScoped\npublic class TaskProducers implements Serializable {\n\nTaskType taskType = TaskType.ASYNC;\npublic TaskProducers() {\nSystem.out.println(“TaskProducers constructor called”);\n}\n\n/**\n\n*   change from @RequestScoped to @ApplicationScoped to see what happened.\n\n*   @TODO why @SessionScoped failed here?\n*   @param asyncTask async task\n*   @param syncTask sync task\n*   @return Task according to TaskType\n    */\n    @Produces\n    @Preferred\n    @SessionScoped\n    public Task getTask(AsyncTask asyncTask, SyncTask syncTask) {\n    System.out.println(“getTask called…”);\n    switch (taskType) {\n    case ASYNC:\n    return asyncTask;\n    case SYNC:\n    return syncTask;\n    default:\n    return null;\n    }\n    }\n    }\n    大家看到这里@Produces修饰Task类型的getTask()方法，并且添加一个Qualifter: @Preferred,也就是说produces 也可以通过qualifter来区分。而且大家都知道在CDI中名字并不重要，重要的是组件类型。也就是说getTask()方法可以修改为任意名字。还有就是可被申请的组件需要同过参数的形式注入。\n\n调用组件TaskController.java\n\n@Model\npublic class TaskController {\n\n@Inject\n@Preferred\nTask task;\n\npublic String sayHello() {\nreturn “hello task:” + task.getName();\n}\n\n@PostConstruct\npublic void init() {\nSystem.out.println(“GreetingController post construct…”);\n}\n\n@PreDestroy\npublic void destroy() {\nSystem.out.println(“GreetingController pre destroy…”);\n}\n}\n这样调用的就是Async组件；\n\n介绍其他几个注解：\n\n@Model = @Name + @RequestScope\n@PostConstruct:初始化组件，功能相当于构造器\n@PreDestory:销毁组件"]],[131,131],[5831,5831]]],[1561022300206,["tyk50@tangyukun",[[1,131,"\n"]],[130,130],[131,131]]]],null,"tyk50@tangyukun"]]}