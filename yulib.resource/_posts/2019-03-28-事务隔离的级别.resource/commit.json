{"compress":true,"commitItems":[["ddde8c62-70c4-43a8-a5d1-0feae7c124fc",1561000571838,"",[[1561000522031,["tyk50@tangyukun",[[1,0,"# 2019-03-28-事务隔离的级别\n\n\n\n"]],[0,0],[23,23]]],[1561000524457,["tyk50@tangyukun",[[-1,0,"# 2019-03-28-事务隔离的级别\n"],[1,21,"这些都是基础知识，不过有必要做深入了解。先简单介绍一下。\n\n二者的定义：\n\n当你在浏览网站的时候，WEB 服务器会先送一小小资料放在你的计算机上，Cookie 会帮你在网站上所打的文字或是一些选择，\n\n都纪录下来。当下次你再光临同一个网站，WEB 服务器会先看看有没有它上次留下的 Cookie 资料，有的话，就会依据 Cookie\n\n里的内容来判断使用者，送出特定的网页内容给你。 Cookie 的使用很普遍，许多有提供个人化服务的网站，都是利用 Cookie\n\n来辨认使用者，以方便送出使用者量身定做的内容，像是 Web 接口的免费 email 网站，都要用到 Cookie。\n\n具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。\n\n同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制\n\n来达到保存标识的目的，但实际上它还有其他选择。\n\ncookie机制。正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示\n\n浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。而cookie的使用\n\n是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围\n\n大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。\n\ncookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这\n\n个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。\n\n会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie\n\n保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏\n\n览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式\n\nsession机制。session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。\n\n```\n      当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识\n\n```\n\n（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来\n\n使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相\n\n关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应\n\n中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给\n\n服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时\n\n仍然能够把session id传递回服务器。\n\n经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器\n\n会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如：\n\n实际上这种技术可以简单的用对action应用URL重写来代替。\n\ncookie 和session 的区别：\n\n1、cookie数据存放在客户的浏览器上，session数据放在服务器上。\n\n2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗\n考虑到安全应当使用session。\n\n3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能\n考虑到减轻服务器性能方面，应当使用COOKIE。"],[1,23,"4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。\n\n5、所以个人建议：\n将登陆信息等重要信息存放为SESSION\n其他信息如果需要保留，可以放在COOKIE中"]],[0,23],[1977,1977]]],[1561000526190,["tyk50@tangyukun",[[-1,0,"这些都是基础知识，不过有必要做深入了解。先简单介绍一下。\n\n二者的定义：\n\n当你在浏览网站的时候，WEB 服务器会先送一小小资料放在你的计算机上，Cookie 会帮你在网站上所打的文字或是一些选择，\n\n都纪录下来。当下次你再光临同一个网站，WEB 服务器会先看看有没有它上次留下的 Cookie 资料，有的话，就会依据 Cookie\n\n里的内容来判断使用者，送出特定的网页内容给你。 Cookie 的使用很普遍，许多有提供个人化服务的网站，都是利用 Cookie\n\n来辨认使用者，以方便送出使用者量身定做的内容，像是 Web 接口的免费 email 网站，都要用到 Cookie。\n\n具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。\n\n同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制\n\n来达到保存标识的目的，但实际上它还有其他选择。\n\ncookie机制。正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示\n\n浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。而cookie的使用\n\n是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围\n\n大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。\n\ncookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这\n\n个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。\n\n会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie\n\n保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏\n\n览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式\n\nsession机制。session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。\n\n```\n      当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识\n\n```\n\n（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来\n\n使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相\n\n关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应\n\n中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给\n\n服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时\n\n仍然能够把session id传递回服务器。\n\n经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器\n\n会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如：\n\n实际上这种技术可以简单的用对action应用URL重写来代替。\n\ncookie 和session 的区别：\n\n1、cookie数据存放在客户的浏览器上，session数据放在服务器上。\n\n2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗\n考虑到安全应当使用session。\n\n3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能\n考虑到减轻服务器性能方面，应当使用COOKIE。\n\n4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。\n\n5、所以个人建议：\n将登陆信息等重要信息存放为SESSION\n其他信息如果需要保留，可以放在COOKIE中\n"]],[0,1978],[0,0]]],[1561000535716,["tyk50@tangyukun",[[1,0,"---\nlayout: post\ntitle: cookie & session\ndate: 2019-03-27\ntags:\n  - JAVA \ncategories: \n  - JAVA\n---\n==第五周WEB JAVA作业（2）==\n<!-- more -->\n\n"]],[0,0],[135,135]]],[1561000537272,["tyk50@tangyukun",[[-1,116,"2"]],[117,117],[116,116]]],[1561000537632,["tyk50@tangyukun",[[1,116,"4"]],[116,116],[117,117]]],[1561000550717,["tyk50@tangyukun",[[1,135,"数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed 、Repeatable read 、Serializable 。而且，在事务的并发操作中可能会出现脏读，不可重复读，幻读。下面通过事例一一阐述它们的概念与联系。\n\nRead uncommitted\n\n读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。\n\n事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。\n\n分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。\n\n那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。\n\nRead committed\n\n读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。\n\n事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…\n\n分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。\n\n那怎么解决可能的不可重复读问题？Repeatable read ！\n\nRepeatable read\n\n重复读，就是在开始读取数据（事务开启）时，不再允许修改操作\n\n事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。\n\n分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。\n\n什么时候会出现幻读？\n\n事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。\n\n那怎么解决幻读问题？Serializable！\n\nSerializable 序列化\n\nSerializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。\n\n值得一提的是：大多数数据库默认的事务隔离级别是Read committed，比如Sql Server , Oracle。Mysql的默认隔离级别是Repeatable read。"]],[135,135],[1598,1598]]]],null,"tyk50@tangyukun"]]}